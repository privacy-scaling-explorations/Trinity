<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>trinity-doc</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">trinity-doc</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-trinity"><a class="header" href="#introduction-to-trinity">Introduction to Trinity</a></h1>
<p><img src="./images/trinity_banner.png" alt="MP-FHE" /></p>
<h2 id="what-is-trinity"><a class="header" href="#what-is-trinity">What is Trinity?</a></h2>
<p>Trinity is a two-party computation (2PC) protocol designed to minimize interaction rounds, enable input verifiability, and facilitate reusability. It combines three key cryptographic concepts:</p>
<ul>
<li>Extractable Witness Encryption, powering Laconic Oblivious Transfer (LOT).</li>
<li>Garbled Circuits.</li>
<li>PLONK for verifiable inputs.</li>
</ul>
<p>The core mechanism unifying these concepts is the KZG polynomial commitment scheme. Trinity offers a novel approach to handling user data by placing data objects at the center of computation. Users can commit to structured data (e.g., dictionaries), generate verifiable proofs about their contents, and privately interact with other parties.</p>
<p>The main goal of Trinity is to shift the perspective on zero-knowledge proofs (ZKPs) beyond simple gate computations, enabling them instead to serve as verified private inputs within secure 2PC interactions.</p>
<h2 id="how-is-trinity-different-from-other-approaches"><a class="header" href="#how-is-trinity-different-from-other-approaches">How Is Trinity Different From Other Approaches?</a></h2>
<p>Let’s assume Alice and Bob each hold a private input (<code>a</code>, <code>b</code>) and want to compute <code>f(a, b)</code> without revealing anything to each other. There are several cryptographic ways to achieve this, each with different trade-offs:</p>
<h3 id="1-multiparty-fhe-fully-homomorphic-encryption"><a class="header" href="#1-multiparty-fhe-fully-homomorphic-encryption">1. <strong>Multiparty FHE (Fully Homomorphic Encryption)</strong></a></h3>
<p>FHE enables computing arbitrary functions on encrypted inputs. With multiparty FHE, each party encrypts their inputs under a joint key, and computation happens homomorphically.</p>
<p><img src="./images/MP-FHE.png" alt="MP-FHE" /></p>
<ul>
<li><strong>Pros</strong>:
<ul>
<li>Minimal interaction.</li>
<li>Can delegate computation to untrusted servers.</li>
</ul>
</li>
<li><strong>Cons</strong>:
<ul>
<li>High computational cost, even for simple functions.</li>
<li>Still impractical for most real-time use cases.</li>
<li>Complex key management across parties.</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>Good fit when clients are weak and untrusted computation is offloaded to powerful servers (e.g., dark pools, PSI).</em></p>
</blockquote>
<hr />
<h3 id="2-secret-sharing-based-mpc"><a class="header" href="#2-secret-sharing-based-mpc">2. <strong>Secret Sharing-based MPC</strong></a></h3>
<p>Each party splits their input into shares and distributes them across multiple computation nodes. The function <code>f</code> is then evaluated collaboratively over the shares.</p>
<ul>
<li><strong>Pros</strong>:
<ul>
<li>Efficient for many inputs and functions.</li>
<li>Mature tooling.</li>
</ul>
</li>
<li><strong>Cons</strong>:
<ul>
<li>Requires high liveness and low latency between nodes.</li>
<li>Expensive in bandwidth and synchronization.</li>
<li>Hard to scale in high-latency environments.</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>Great when you control your infrastructure or have low-latency assumptions (e.g., private statistics, secure ML inference).</em></p>
</blockquote>
<hr />
<h3 id="3-garbled-circuits-with-classical-ot"><a class="header" href="#3-garbled-circuits-with-classical-ot">3. <strong>Garbled Circuits with Classical OT</strong></a></h3>
<p>In classical 2PC using GC, one party (the <em>garbler</em>) encrypts the circuit, and the other (the <em>evaluator</em>) receives encrypted wire values via <strong>Oblivious Transfer</strong> (OT). It's a well-established approach with strong security guarantees under semi-honest or malicious models.</p>
<p><img src="./images/Trad-GC.png" alt="Trad-GC" /></p>
<ul>
<li><strong>Pros</strong>:
<ul>
<li>Mature cryptographic primitive.</li>
<li>Supports arbitrary functions.</li>
<li>Non-interactive once the circuit is garbled and inputs are transferred.</li>
</ul>
</li>
<li><strong>Cons</strong>:
<ul>
<li>No built-in verifiability of inputs — relies on trusted setup or assumptions.</li>
<li>Cannot reuse or prove input commitments across sessions.</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>Good for basic 2PC with moderate setup cost when parties are trusted to follow protocol but don’t want to reveal inputs.</em></p>
</blockquote>
<hr />
<h3 id="4-trinity-laconic-ot--gc--zk-inputs"><a class="header" href="#4-trinity-laconic-ot--gc--zk-inputs">4. <strong>Trinity: Laconic OT + GC + ZK Inputs</strong></a></h3>
<p>Trinity enables two parties to compute a function using garbled circuits — with a twist:</p>
<ul>
<li><strong>Inputs are committed with KZG</strong>.</li>
<li><strong>Verifiability is added via ZK (PLONK)</strong>.</li>
<li><strong>Oblivious Transfer is optimized using Extractable Witness Encryption</strong>.</li>
</ul>
<p><img src="./images/Trinity.png" alt="Trinity" /></p>
<ul>
<li><strong>Pros</strong>:
<ul>
<li>Input integrity is provable.</li>
<li>Few interaction rounds (Laconic OT).</li>
<li>No need to trust delegated infrastructure.</li>
<li>Input commitment is reusable.</li>
</ul>
</li>
<li><strong>Cons</strong>:
<ul>
<li>Limited to 2PC.</li>
<li>Verifiability with Halo2 PLONK is costly.</li>
</ul>
</li>
</ul>
<blockquote>
<p><em>Ideal for verified 2PC in low-trust environments where inputs need to be reused or proven (e.g., self-attested data proofs, benchmarking, private voting).</em></p>
</blockquote>
<hr />
<h3 id="-comparison-table"><a class="header" href="#-comparison-table">📊 Comparison Table</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Approach</th><th>Trust Model</th><th>Interaction Rounds</th><th>Computation Cost</th><th>Bandwidth</th><th>Input Verifiability</th><th>Best For</th></tr></thead><tbody>
<tr><td><strong>FHE</strong></td><td>Untrusted server</td><td>Low</td><td>🚨 High</td><td>Low</td><td>❌</td><td>Offloaded compute</td></tr>
<tr><td><strong>Secret Sharing MPC</strong></td><td>Honest majority</td><td>High</td><td>Moderate</td><td>High</td><td>❌</td><td>Server-side compute</td></tr>
<tr><td><strong>GC + Classical OT</strong></td><td>No delegation, Semi-honest</td><td>Moderate</td><td>Moderate</td><td>Moderate</td><td>❌</td><td>Generic 2PC</td></tr>
<tr><td><strong>Trinity (GC + LOT + ZK)</strong></td><td>No delegation, Semi-honest (+ZK)</td><td>🔁 Few</td><td>Low–Moderate</td><td>Low</td><td>✅ (PLONK)</td><td>Verified 2PC, reusable inputs</td></tr>
</tbody></table>
</div>
<h2 id="-applications-and-use-cases"><a class="header" href="#-applications-and-use-cases">🧩 Applications and Use Cases</a></h2>
<p>Trinity is built for use cases that <strong>don’t require liveness</strong> — meaning participants can interact <strong>asynchronously</strong>, without being online at the same time. It’s ideal for <strong>private matching</strong>, <strong>selective interactions</strong>, and <strong>verifiable decision logic</strong> over user data.</p>
<p>At its core, Trinity allows a user to:</p>
<ul>
<li>Commit to a <strong>bitstring</strong> representing their private input (e.g., encoded attributes, preferences, or selections),</li>
<li>Prove the <strong>validity of this input</strong> via a zero-knowledge proof (e.g., PLONK),</li>
<li>Publish the commitment and proof (e.g., on-chain or off-chain),</li>
<li>Allow others to interact by garbling a circuit with their own private inputs and returning it for evaluation.</li>
</ul>
<h3 id="-use-case-provable-listings--private-bidding-the-weeknd-concert-ticket"><a class="header" href="#-use-case-provable-listings--private-bidding-the-weeknd-concert-ticket">🛒 <strong>Use Case: Provable Listings &amp; Private Bidding (The Weeknd Concert Ticket)</strong></a></h3>
<p>Imagine a user wants to resell a concert ticket. Here's how Trinity could support a privacy-preserving, verifiable flow:</p>
<ol>
<li>
<p><strong>Ownership Proof</strong><br />
The seller generates a ZK proof of ticket ownership using, for example, a ZKEmail circuit verified via Halo2.</p>
</li>
<li>
<p><strong>Price Encoding and Commitment</strong><br />
They encode their desired price range (e.g., 100–150 USD) as a bitstring input to a 2PC Boolean circuit, and commit to it in the same Halo2 circuit as above.</p>
</li>
<li>
<p><strong>Public Posting</strong><br />
The ZK proof containing the KZG commitmentare is posted (e.g., on a smart contract or IPFS), making the listing publicly visible but still private in terms of content.</p>
</li>
<li>
<p><strong>Private Offer Submission</strong><br />
A buyer retrieves the public circuit, garbles it with their own price offer (also as a bitstring), and sends the garbled circuit back.</p>
</li>
<li>
<p><strong>Secure Evaluation</strong><br />
The seller evaluates the garbled circuit to check whether the offer matches their private range, learning only whether it is acceptable — not the exact bid.</p>
</li>
</ol>
<blockquote>
<p>This enables <strong>sealed-bid auctions</strong>, <strong>private marketplaces</strong>, or <strong>anonymous deal matching</strong>, while retaining cryptographic integrity.</p>
</blockquote>
<hr />
<h3 id="-additional-scenarios"><a class="header" href="#-additional-scenarios">🎮 Additional Scenarios</a></h3>
<ul>
<li>
<p><strong>ZK Social Discovery</strong>:<br />
Users encode and commit to private attributes (e.g., age &gt; 18 through anon-aadhaar or self.xyz, shared interest tags), and interact via circuits that match compatible criteria without revealing exact values.</p>
</li>
<li>
<p><strong>Private Gameplay</strong>:<br />
In games involving secret strategies (e.g., card games, bluff mechanics), players commit to private state and verify interactions using 2PC.</p>
</li>
<li>
<p><strong>Credential Matching</strong>:<br />
In employment or dating contexts, participants encode structured claims (e.g., degrees, preferences, income ranges) and privately compute matches.</p>
</li>
</ul>
<h2 id="structure-of-this-documentation"><a class="header" href="#structure-of-this-documentation">Structure of this Documentation</a></h2>
<ul>
<li><strong><a href="./laconic_ot.html">Laconic Oblivious Transfer</a></strong>: Learn about the efficient OT protocol used in Trinity.</li>
<li><strong><a href="./gc_lot.html">Garbled Circuits and Laconic OT</a></strong>: Understand how garbled circuits are combined with LOT.</li>
<li><strong><a href="./zk_input_commit.html">ZK Input Verification with PLONK/KZG</a></strong>: Explore how inputs are made verifiable using ZK proofs.</li>
</ul>
<h2 id="target-audience"><a class="header" href="#target-audience">Target Audience</a></h2>
<p>This documentation is tailored for cryptographers, developers, and researchers seeking to leverage Trinity’s advanced cryptographic techniques for secure, verifiable, and private two-party computation.</p>
<h2 id="acknowledgments"><a class="header" href="#acknowledgments">Acknowledgments</a></h2>
<p>We would like to thank all contributors, researchers, and supporters who have helped make Trinity possible. Special thanks to <a href="https://github.com/RiverRuby">Vivek</a> and the <a href="https://github.com/cursive-team">Cursive team</a> for originally designing the scheme, the research team behind the <a href="https://github.com/rot256/research-we-kzg">Laconic OT paper and their implementation</a>. Thanks <a href="https://github.com/nakkstar123">Nakul</a> and <a href="https://github.com/brech1">brech1</a> for their help in integrating secure garbling and Halo2 LOT. Additionally, we extend our gratitude to the authors of the <a href="https://github.com/privacy-scaling-explorations/mpz">mpz</a> library and the <a href="https://github.com/privacy-scaling-explorations/halo2">PSE Halo2</a> team for their foundational work and inspiration.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="laconic-oblivious-transfer-ot"><a class="header" href="#laconic-oblivious-transfer-ot">Laconic Oblivious Transfer (OT)</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>Laconic OT plays a crucial role in Trinity, it's the core fo the protocol that enables fewer round of communication between the two parties.</p>
<ul>
<li>
<p><strong>Definition</strong>:<br />
Laconic Oblivious Transfer (Laconic OT) is a two-message protocol where the <strong>receiver holds a large input</strong> (typically a dictionary $D$), and the <strong>sender holds a small input</strong>—an index $i$ and two messages $m_0$, $m_1$. The receiver learns $m_b$, where $b = D[i]$ is the $i$-th bit of their dictionary, without learning anything about $m_{1-b}$. Meanwhile, the sender learns nothing about the receiver's dictionary.</p>
</li>
<li>
<p><strong>Motivation</strong>:<br />
Laconic OT is crucial for secure two-party computation in bandwidth-constrained or interaction-minimal settings. It minimizes communication by shifting the burden of computation to the receiver (reverse delegation), enabling succinct, two-message protocols in advanced cryptographic settings like:</p>
<ul>
<li><strong>RAM programs with private memory access</strong></li>
<li><strong>Private set intersection</strong></li>
</ul>
</li>
</ul>
<p>This is a traditional OT between Alice and Bob. Informally, OT guarantees that Bob receives from Alice the message corresponding to his choice bit $b$ (i.e., $m_b$), without revealing $b$ to Alice or learning anything about $m_{1-b}$.</p>
<p><img src="./images/OT-communication.png" alt="OT-communication" /></p>
<p>In the traditional protocol, each message transfer requires two rounds of communication between Alice and Bob.</p>
<p>The Laconic version of OT improves efficiency. Bob compresses all his $n$ bits into a dictionary $D$ and sends a succinct commitment of $D$ to Alice. This allows the transfer of $n$ messages between Alice and Bob in just two communication rounds—effectively batching all the Oblivious Transfers together.</p>
<p><img src="./images/LOT-communication.png" alt="LOT-communication" /></p>
<p>Witness Encryption (WE) for KZG is used to compress the dictionary Bob sends. After receiving the commitment $\mathcal{com}$ from Bob, Alice encrypts her messages under the KZG openings. For example, she encrypts $m_0^1$ under the opening for $0$ at position $1$, and $m_1^1$ under the opening for $1$ at position $1$. Bob can only decrypt the message corresponding to the bit he committed to at position $1$ of $D$, by providing a valid opening proof.</p>
<h2 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h2>
<h3 id="the-laconic-property"><a class="header" href="#the-laconic-property">The Laconic Property</a></h3>
<p>"Laconic" in this context refers to <strong>communication complexity being sublinear</strong> in the receiver's input size. Instead of transmitting the entire database or program, the receiver sends a <strong>digest</strong> (a succinct commitment), and the sender replies with a short ciphertext. This is especially beneficial when:</p>
<ul>
<li>The receiver has large input ($D \in {0,1}^n$)</li>
<li>The sender’s input and communication must remain small</li>
<li>Round complexity is critical (only 2 messages total)</li>
</ul>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Enables practical, low-latency secure computation</li>
<li>Avoids heavy public-key operations in the online phase</li>
<li>Supports applications like RAM access, PSI, and circuit obfuscation</li>
</ul>
<h2 id="technical-explanation"><a class="header" href="#technical-explanation">Technical Explanation</a></h2>
<p>We now describe the actual Laconic OT construction, following the structure from the 2024 paper <em>Extractable Witness Encryption for KZG Commitments and Efficient Laconic OT</em>.</p>
<h3 id="setup-phase"><a class="header" href="#setup-phase">Setup Phase</a></h3>
<ul>
<li>The setup takes the security parameter ( $\lambda$ ) and the database size ( $n$ ).</li>
<li>It runs the setup of a vector commitment scheme (VC):</li>
</ul>
<p>$$
\text{pp} \leftarrow \text{VC.Setup}(1^\lambda, 1^n)
$$</p>
<h3 id="hashing-the-receivers-input"><a class="header" href="#hashing-the-receivers-input">Hashing the Receiver's Input</a></h3>
<ul>
<li>The receiver (Bob) has a database $D \in {0,1}^n$.</li>
<li>He computes a commitment to $D$ and prepares opening proofs:</li>
</ul>
<p>$$
(\mathsf{com}, \overline{\mathsf{aux}}) \leftarrow \text{VC.Commit}(\text{pp}, D)
$$</p>
<p>$$
(\pi_1, \dots, \pi_n) \leftarrow \text{BatchOpen}(\text{pp}, \overline{\mathsf{aux}})
$$</p>
<ul>
<li>He sends $\mathsf{digest} = (\mathsf{com}, D, \pi_1, \dots, \pi_n)$ to the sender.</li>
</ul>
<h3 id="senders-message-encoding"><a class="header" href="#senders-message-encoding">Sender’s Message Encoding</a></h3>
<ul>
<li>Given the digest, the sender (Alice) chooses an index ( $i$ ) and two messages ( $m_0$, $m_1$ ).</li>
<li>She encrypts them under witness encryption for the statements:<br />
“bit at index ( $i$ ) is 0” and “bit at index ( $i$ ) is 1”:</li>
</ul>
<p>$$
ct_0 \leftarrow \text{WE.Enc}(\text{pp}, (\mathsf{digest}, i, 0), m_0)
$$</p>
<p>$$
ct_1 \leftarrow \text{WE.Enc}(\text{pp}, (\mathsf{digest}, i, 1), m_1)
$$</p>
<ul>
<li>She sends ($ct_0$, $ct_1$) to the receiver.</li>
</ul>
<h3 id="receivers-decryption"><a class="header" href="#receivers-decryption">Receiver’s Decryption</a></h3>
<ul>
<li>The receiver knows the opening proof ($\pi_i$) for index $i$, and the bit $b = D[i]$.</li>
<li>He uses it as a witness to decrypt the corresponding ciphertext:</li>
</ul>
<p>$$
m_b \leftarrow \text{WE.Dec}(\text{pp}, \pi_i, c_b)
$$</p>
<ul>
<li>Security ensures he cannot decrypt $ct_{1-b}$.</li>
</ul>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<p>This construction achieves laconicity by collapsing the full database $D$ into a short digest. Using KZG-based vector commitments and Witness Encryption, the sender encrypts under assumptions about the receiver’s bits. Only valid openings allow correct decryption, enforcing privacy and minimal communication.</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>
<p><strong>Original Laconic OT Paper</strong><br />
Fleischhacker et al., <em>Extractable Witness Encryption for KZG Commitments and Efficient Laconic OT</em>, 2024
[<a href="https://eprint.iacr.org/2017/972">Paper link</a>]</p>
</li>
<li>
<p><strong>Private Laconic OT with Preprocessing</strong><br />
Bhadauria et al., <em>Private Laconic OT with Preprocessing</em>, 2024<br />
[<a href="https://eprint.iacr.org/2024/264">Paper link</a>]<br />
[<a href="https://eurocrypt.iacr.org/2024/accepted.html">Conference page</a>]</p>
</li>
<li>
<p><strong>Leku blogpost on Extractable Witness Encryption for KZG</strong><br />
[<a href="https://www.leku.blog/kzg-we/">HackMD link</a>]</p>
</li>
<li>
<p><strong>Video Presentation</strong><br />
<a href="https://www.youtube.com/watch?v=81Hq7Ij94vE">YouTube: "Extractable Witness Encryption for KZG Commitments and Efficient Laconic OT" (authors' presentation)</a></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="garbled-circuits-and-laconic-ot"><a class="header" href="#garbled-circuits-and-laconic-ot">Garbled Circuits and Laconic OT</a></h1>
<h2 id="introduction-to-garbled-circuits"><a class="header" href="#introduction-to-garbled-circuits">Introduction to Garbled Circuits</a></h2>
<p><strong>Garbled circuits</strong> enable secure two-party computation where one party (the garbler) encrypts a circuit such that another party (the evaluator) can evaluate it without learning the garbler’s inputs or the intermediate values.</p>
<h3 id="basic-workflow"><a class="header" href="#basic-workflow">Basic Workflow</a></h3>
<ul>
<li>
<p><strong>Garbler</strong>:</p>
<ul>
<li>Generates encryption keys for each wire and bit value.</li>
<li>Encrypts the truth table of each gate with the corresponding keys ("garbling").</li>
<li>Shares encrypted circuit + encrypted labels for evaluator’s inputs.</li>
</ul>
</li>
<li>
<p><strong>Evaluator</strong>:</p>
<ul>
<li>Obtains one encrypted label per input bit via <strong>Oblivious Transfer (OT)</strong>.</li>
<li>Uses these to traverse the circuit gate-by-gate.</li>
<li>Retrieves garbler's output via decoding bits.</li>
</ul>
</li>
</ul>
<h2 id="integrating-laconic-ot"><a class="header" href="#integrating-laconic-ot">Integrating Laconic OT</a></h2>
<h3 id="how-trinity-uses-laconic-ot-in-garbled-circuits"><a class="header" href="#how-trinity-uses-laconic-ot-in-garbled-circuits">How Trinity Uses Laconic OT in Garbled Circuits</a></h3>
<p>Instead of executing one classical OT per bit of evaluator input, Trinity uses Laconic OT to compress all OT interactions into a two-message digest commitment. This minimizes round complexity and bandwidth.</p>
<h3 id="integration-flow"><a class="header" href="#integration-flow">Integration Flow</a></h3>
<ol>
<li>
<p><strong>Evaluator Side</strong></p>
<ul>
<li>Converts each bit of input into a <code>TrinityChoice</code> (Zero or One).</li>
<li>Generates an OT receiver and a commitment using:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let ot_receiver = trinity.create_ot_receiver(&amp;evaluator_bits)?;
let receiver_commitment = ot_receiver.trinity_receiver.commitment();
<span class="boring">}</span></code></pre></pre>
</li>
<li>Sends this single commitment to the garbler.</li>
</ul>
</li>
<li>
<p><strong>Garbler Side</strong></p>
<ul>
<li>Initializes an OT sender with the evaluator’s commitment.</li>
<li>For each evaluator input bit, computes the two wire labels (one per bit value):
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let key = &amp;input_keys[key_idx];
let zero_label = key.clone();
let one_label = Key::from(*key.as_block() ^ delta.as_block());
<span class="boring">}</span></code></pre></pre>
</li>
<li>Sends these via OT:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>ot_sender.trinity_sender.send(rng, i, m0, m1)
<span class="boring">}</span></code></pre></pre>
</li>
<li>The result is a ciphertext (<code>TrinityMsg</code>) for each bit.</li>
</ul>
</li>
<li>
<p><strong>Evaluator Decryption</strong></p>
<ul>
<li>Receives the correct label without revealing the input bit:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let decrypted = ot_receiver.trinity_receiver.recv(i, ciphertext);
let mac = Mac::from(Block::new(decrypted));
<span class="boring">}</span></code></pre></pre>
</li>
<li>The MAC becomes an authenticated input to the garbled circuit.</li>
</ul>
</li>
</ol>
<h3 id="diagram-evaluator--garbler"><a class="header" href="#diagram-evaluator--garbler">Diagram (Evaluator ↔ Garbler)</a></h3>
<pre><code>Evaluator Inputs (bits)
       │
       ▼
[TrinityChoice::Zero, TrinityChoice::One, ...]
       │
       ▼
KZGOTReceiver::commit() ──▶ Commitment ─────────┐
                                              │
                                   ┌──────────┴────────────┐
                                   ▼                       ▼
                Garbler generates wire labels      Garbler runs OT:
                   zero_label, one_label           ot_sender.send(i, m0, m1)
                                   │                       │
                                   └────── Ciphertexts  ◀──┘
                                                           ▼
                                               Evaluator runs OT recv()
                                                    and gets correct MAC
</code></pre>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>By directly embedding Laconic OT into the garbling pipeline, Trinity avoids per-bit communication, reducing both communication and computational overhead. Each evaluator input bit is matched with the correct wire label through a single global commitment, preserving circuit privacy and ensuring scalable 2PC execution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zk-input-verification-with-plonkkzg"><a class="header" href="#zk-input-verification-with-plonkkzg">ZK Input Verification with PLONK/KZG</a></h1>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<h3 id="zero-knowledge-proofs-zkps"><a class="header" href="#zero-knowledge-proofs-zkps">Zero-Knowledge Proofs (ZKPs)</a></h3>
<p>ZKPs allow a prover to convince a verifier that they know a value satisfying some condition, <strong>without revealing the value itself</strong>.</p>
<h3 id="plonk-and-kzg-commitments"><a class="header" href="#plonk-and-kzg-commitments">PLONK and KZG Commitments</a></h3>
<ul>
<li><strong>PLONK</strong> is a universal and updatable SNARK that supports efficient proofs over arbitrary circuits. It allows inputs to be committed using polynomial commitment schemes.</li>
<li><strong>KZG Commitments</strong> are polynomial commitments with succinct size and verification. They allow the prover to commit to a polynomial and later prove evaluations at specific points.</li>
</ul>
<h2 id="usage-in-trinity"><a class="header" href="#usage-in-trinity">Usage in Trinity</a></h2>
<h3 id="verifiable-inputs"><a class="header" href="#verifiable-inputs">Verifiable Inputs</a></h3>
<p>In Trinity, input bits committed by the evaluator need to be <strong>verifiable</strong>—they must be provably constrained to binary values and committed in a zero-knowledge way.</p>
<p>Rather than computing a KZG commitment inside a circuit (which would be expensive due to multi-scalar multiplications), we leverage <strong>PLONK’s native use of KZG commitments</strong> for advice columns.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h3>
<ol>
<li><strong>Setup</strong>: A Halo2 circuit is built where the evaluator’s input bit vector is placed in an <strong>advice column</strong>.</li>
<li><strong>Constraint</strong>: Each value is constrained to be a bit (0 or 1) using a simple custom gate:
$$ s \cdot b \cdot (b - 1) = 0 $$</li>
<li><strong>Proof Generation</strong>: The prover runs Halo2’s KZG-based proving system.</li>
<li><strong>Commit Extraction</strong>: The resulting proof includes a commitment to the advice column—this commitment is extracted and reused in Trinity’s Laconic OT as the receiver’s commitment.</li>
</ol>
<h3 id="code-summary"><a class="header" href="#code-summary">Code Summary</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let circuit = BitvectorCommitmentCircuit { bitvector };
let proof = create_proof(...);
let commitments = extract_commitments(&amp;proof, 1); // Gets KZG commit to advice column
let com = commitments[0];
<span class="boring">}</span></code></pre></pre>
<p>This commitment becomes the receiver’s <code>Com</code> in Laconic OT.</p>
<h3 id="visual-overview"><a class="header" href="#visual-overview">Visual Overview</a></h3>
<p><img src="./images/advice_column.png" alt="Advice Column Illustration" /></p>
<pre><code>Advice Column:   [ 1, 0, 1, 1, 0, 0 ]
Constraint:      s * b * (b - 1) = 0  for all b
Commitment:      Com(advice_poly)
Output:          KZG Commitment (G1 point)
</code></pre>
<h2 id="benefits-and-considerations"><a class="header" href="#benefits-and-considerations">Benefits and Considerations</a></h2>
<h3 id="advantages"><a class="header" href="#advantages">Advantages</a></h3>
<ul>
<li><strong>Verifiability</strong>: Inputs are guaranteed to be well-formed bitstrings, but you can extend checks to verify a signature or any computation over the bitstring data.</li>
<li><strong>Trust Shift</strong>: The evaluator’s commitment is now backed by a ZK proof.</li>
<li><strong>Reuse</strong>: Proofs are reusable across OT and other verification protocols.</li>
</ul>
<h3 id="trade-offs"><a class="header" href="#trade-offs">Trade-offs</a></h3>
<ul>
<li><strong>Proof Overhead</strong>: Circuit setup and proof generation are heavier than Plain OT (raw KZG commitment).</li>
<li><strong>Performance</strong>: Halo2’s proving time and constraint system size must be managed.</li>
</ul>
<h2 id="practical-example"><a class="header" href="#practical-example">Practical Example</a></h2>
<ol>
<li><strong>Evaluator Generates a Proof</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let bitvector = vec![Fr::one(), Fr::zero(), Fr::one()];
kzg_commitment_with_halo2_proof(params, bitvector)
<span class="boring">}</span></code></pre></pre>
<ol start="2">
<li><strong>Extract Commitment</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let com = circuit_output.commitment; // G1 commitment to advice column
<span class="boring">}</span></code></pre></pre>
<ol start="3">
<li><strong>Use in OT</strong></li>
</ol>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let receiver = LaconicOTRecv::new(halo2params, &amp;[Choice::One, Choice::Zero, Choice::One]);
let com = receiver.commitment();
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
